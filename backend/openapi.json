{"openapi":"3.0.2","info":{"title":"matcher backend","description":"\nThis API handles core cheminformatics logic of the matcher application.\n\nThis backend API can be used to run queries and interrogate results, independently of the matcher frontend.\n\n## Running a query asynchronously\n\nFollow the below steps to run a matcher-style query against the database containing MMP data.\n\nQueries are run asynchronously to prevent blocking by longer queries.\n\n0. (Optional) Validate the variable/environment atom/bond selections within input structure(s) using the /validateSelection endpoint\n\n1. Pass query input to the /start_query endpoint, which quickly returns a query_id. The API then triggers the query asynchronously. <strong>Use the returned query_id for all subsequent endpoints below</strong>\n\n2. Monitor query progress using the /check_query endpoint. The query is complete when the returned JSON \"finished\" key has a value of \"True\"\n\n3. Results (if any are found by the query) are stored in the database query_result table, where query_result.query_id is the query_id returned by the /start_query endpoint above\n\n## Get query results\n\n<strong>To dump all results at once:</strong> when the query is finished, as indicated by /check_query, pass the query_id obtained from /start_query to /get_all_raw_data to obtain a list of MMPs (matched molecular pairs) found by the query, along with all associated structure/activity/transform data for each MMP.\n\n<strong>What the matcher application does to get results:</strong>\n\nThe below endpoints were developed for more selective, iterated, scalable results gathering. For example, if a query finds 1 million MMPs, it's impractical to pass all that data over the network and/or store it in memory, especially because the user often won't care about most of the results. Instead, we can look selectively at interesting subsets of the results.\n\nRun the below endpoints in sequence to go from high-level transform data to low-level MMP data:\n\n<strong>/aggregate_transforms --> /get_plot_data --> /get_pair_data</strong>\n\n* Use /aggregate_transforms to obtain MMP transform-level data, including statistics, e.g. median change in a specified property for each MMP transform found by the query. The matcher frontend uses this data to populate the table of transforms in the frontend results.\n\n* Use /get_plot_data to get data for all MMPs belonging to specific transform(s). As input, the necessary ids for the transforms are provided by /aggregate_transforms. The matcher frontend uses this data to generate a scatterplot, e.g. change in property A vs. change in property B, where each point is an MMP belonging to specified transform(s).\n\n* Use /get_pair_data to get data for specific MMPs. As input, the necessary ids for the pairs are provided by /get_plot_data. The matcher frontend uses this data to display data for individual MMPs. \n","version":"0.1.0"},"paths":{"/validateSelection/":{"post":{"summary":"Validateselection","description":"Checks whether specific atom/bond selections will lead to an illegal query, or will conflict with already selected atoms/bonds\n\nTypical use case: set selected atoms/bonds as either variable or environment\n\n\"Autocorrects\" illegal selections to prevent most such selections that would never lead to results.\n\nFor example, an exact search for a variable fragment that is a subsection of a ring: this search would not find any results, for typical use cases where MMPs were defined with 'fragment and index' algorithms that do not cut cyclic bonds. Therefore, validateSelection would automatically grow the variable selection to be the entire ring, instead of just the subsection of the ring.\n\nAnother example: When trying to set selected atoms as variable atoms, but if some of these atoms were previously set as environment atoms, all environment labels will be cleared due to the overlap.\n\nIn addition, for \"variable\" selections, this endpoint will automatically select single neighboring atom(s) (relative to \"variable\" selection) as an \"environment\" selection (radius 1).\n\nThe matcher frontend buttons labeled \"Set variable atoms\" (i.e. variable_atoms) and \"Set constant atoms\" (i.e. environment_atoms) call this endpoint\n\nParameters:\n\n(note that all atom/bond indices are provided as strings of comma-separated integers, e.g. \"1,2,7\")\n\n- **selection_type**: \"variable\" or \"environment\", the category to which the selected atom indices will be added in sketched_content, after successful validation\n- **sketched_content**: chemical structure constraints of left-hand-side and right-hand-side portions of the MMP transform and environment. The variable/environment atoms/bonds refer to PREVIOUSLY validated selections. **sketched_content** is an object with below items:\n    - **mol1_molfile**: MDL molfile string of the 'starting', 'left-hand-side' structure in the query (if any)\n    - **mol1_variable_atoms**: indices of atoms in the variable fragment (which change as part of the transform). The order of atoms in the molfile defines the atom indices, starting from 0\n    - **mol1_variable_bonds**: indices of bonds in the variable fragment. The order of bonds in the molfile defines the bond indices, starting from 0\n    - **mol1_environment_atoms**: indices of atoms in the environment fragment (which do not change as part of the transform)\n    - **mol1_environment_bonds**: indices of bonds in the environment fragment\n    - **mol2_molfile**: MDL molfile string of the 'ending', 'right-hand-side' structure in the query (if any)\n    - **mol2_variable_atoms**: indices of atoms in the variable fragment (which change as part of the transform). The order of atoms in the molfile defines the atom indices, starting from 0\n    - **mol2_variable_bonds**: indices of bonds in the variable fragment. The order of bonds in the molfile defines the bond indices, starting from 0\n    - **mol2_environment_atoms**: indices of atoms in the environment fragment (which do not change as part of the transform)\n    - **mol2_environment_bonds**: indices of bonds in the environment fragment\n- **mol1_selected_atoms**: indices of atoms in mol1 selected by the user, which are about to undergo validation\n- **mol1_selected_bonds**: indices of bonds in mol1 selected by the user, which are about to undergo validation\n- **mol2_selected_atoms**: indices of atoms in mol2 selected by the user, which are about to undergo validation\n- **mol2_selected_bonds**: indices of bonds in mol2 selected by the user, which are about to undergo validation\n\nReturns JSON with validated variable and environment atom/bond indices:\n\n- **mol1_variable_atoms**: array of integers\n- **mol1_variable_bonds**: array of integers\n- **mol1_environment_atoms**: array of integers\n- **mol1_environment_bonds**: array of integers\n- **mol1_entire_molecule_selected**: \"True\" or \"False\": Used to signal whether the entire structure was selected as a variable fragment. If \"True\", the query will return no results, because matcher relies on detection of borders between variable and non-variable atoms to determine point of attachment of the variable atoms.\n- **mol2_variable_atoms**: array of integers\n- **mol2_variable_bonds**: array of integers\n- **mol2_environment_atoms**: array of integers\n- **mol2_environment_bonds**: array of integers\n- **mol2_entire_molecule_selected**: \"True\" or \"False\": Used to signal whether the entire structure was selected as a variable fragment. If \"True\", the query will return no results, because matcher relies on detection of borders between variable and non-variable atoms to determine point of attachment of the variable atoms.","operationId":"validateSelection_validateSelection__post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ValidateSelectionInput"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/async_query_v3_backend":{"post":{"summary":"Async Query V3 Backend","description":"Deprecated, replaced with /start_query and /check_query","operationId":"async_query_v3_backend_async_query_v3_backend_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueryInput"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"deprecated":true}},"/start_query":{"post":{"summary":"Start Query","description":"Input structure / property constraints, and receive a query_id that will be used for getting results. The query is then initiated asynchronously.\n\nThen, proceed to /check_query to find out when the query is done.\n\nBody Parameters:\n\nWhen using this API in isolation from the matcher application, \"**use default value**\" is recommended for some parameters.\n\n- **snapquery_id**: **use default value**, matcher uses this to avoid duplicating query input state information for snapshotted queries\n- **query_id**: **use default value**, matcher uses this to directly load results and avoid rerunning queries, for snapshotted queries\n- **query_type**: \"exact\" or \"substructure\": specify what kind of search is run on the variable atoms (the atoms that change as part of the MMP transform)\n- **transform_order**: **use default value**, currently only \"first_order\" transform queries are implemented, \"second_order\" could be implemented in the future\n- **sketched_content**: These parameters refer to structures, and highlighted atoms, that would appear in sketcher(s) in the matcher frontend.\n    - See documentation for **sketched_content** under the /validateSelection endpoint. **sketched_content** provides all structural constraints on returned transforms and MMPs. At least one of either mol1 or mol2 below must be filled out. For each mol, a molfile is required, and variable atom(s) indices are required. The environment atom indices are optional.\n    - Not all atom/bond selections, as defined in **sketched_content**, will result in legal queries. The /validateSelection endpoint is designed to detect and correct atom/bond selections that will result in fruitless queries.\n- **OPTIONAL_properties**: comma-separated string of property_name values. Require that both compounds in each MMP result have at least one of these OPTIONAL_properties\n- **REQUIRED_properties**: comma-separated string of property_name values. Require that all compounds belonging to all MMPs in the results have every one of the REQUIRED_properties\n    - At least one property must be provided, as either a REQUIRED or OPTIONAL property\n- **advanced_options**: (OPTIONAL):\n    - **variable_min_heavies**: integer, minimum number of heavy (non-H) atoms in BOTH variable fragments that comprise a transform, for every transform found by the query\n    - **variable_max_heavies**: integer, maximum number of heavy (non-H) atoms in BOTH variable fragments that comprise a transform, for every transform found by the query\n    - **compound_min_heavies**: integer, minimum number of heavy (non-H) atoms in BOTH compounds, in every MMP found by the query\n    - **compound_max_heavies**: integer, maximum number of heavy (non-H) atoms in BOTH compounds, in every MMP found by the query\n    - **aggregation_type**: **use default value**: matcher telegraphs this parameter to subsequent endpoints that control how results are displayed in the frontend (starting with /aggregate_transforms), but this parameter should not affect the initial query itself. Accepted values are \"individual_transforms\" or \"group_by_fragment\"\n    - **snapfilter_id**: **use default value**, can be used to avoid duplication of output filters for snapshotted queries\n    - **snapfilter_string**: **use default value**, used to filter output for snapshotted queries\n\nReturns **query_id**, a positive integer","operationId":"start_query_start_query_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueryInput"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/check_query/{query_id}":{"get":{"summary":"Check Query","description":"Monitor query progress.\n\nParameters:\n\n- **query_id**: The query_id returned by /start_query\n\nReturns JSON with following items:\n\n- **finished**: will evaluate to \"True\" when the query is finished, otherwise \"False\"\n- **finished_with_no_results**: will evaluate to \"True\" if no results were found and saved in DB by the query, otherwise \"False\"","operationId":"check_query_check_query__query_id__get","parameters":[{"required":true,"schema":{"title":"Query Id","type":"integer"},"name":"query_id","in":"path"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/get_all_raw_data":{"post":{"summary":"Get All Raw Data","description":"Retrieve all results for a specific query, after query has finished as indicated by /check_query.\n\nParameters:\n\n- **query_id**: Number returned by /start_query endpoint to run the query of interest\n- **query**: The same data that was passed to /start_query to generate above query_id\n\nReturns JSON with items:\n- **column_headers**: Array of strings (headers) associated with data in **rows**, can be used as columns for a table: smiles, compound_ids, property data, etc.\n- **rows**: Array of arrays (i.e., rows), whose elements match the above column_headers, where each row represents a unique MMP.","operationId":"get_all_raw_data_get_all_raw_data_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/GetAllRawData"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/aggregate_transforms":{"post":{"summary":"Aggregate Transforms","description":"Obtain MMP transform-level data, including statistics, e.g. median change in a specified property for each MMP transform found by the query. The matcher frontend uses this data to populate the table of transforms in the frontend results.\n\nBody Parameters:\n\n- **query_id**: Number returned by /start_query endpoint to run the query of interest\n- **aggregation_type**: \"individual_transforms\" or \"group_by_fragment\": \"individual_transforms\" is the default and will return statistics on a per-transform basis. Alternatively, \"group_by_fragment\" is useful for queries where mol1_variable and mol2_variable fragments are similar or identical, for example searching for \"privileged\" fragments with a specific substructure. Each row returned by \"group_by_fragment\" will show how a specific fragment compares to all other fragments found in the query to which that fragment is related.\n- **statistics**: list of statistics of interest, with below parameters:\n    - **statistic**: currently only \"median\" is implemented, and is implemented at the database level for best performance. For example, obtain the median change in a specific property for all transforms found by the query.\n    - **property_name**: must match one of the property_names in the database property_name table, which were specified with data that was input to the mmpdb loadprops command during database initialization\n    - **change_type**: \"fold_change\" or \"delta\", \"fold_change\" returns a quotient (B / A), \"delta\" returns a difference (B - A), where B is the property value of the right-hand-side compound in the MMP, and A is the property value of the left-hand-side compound in the MMP.\n    - **base**: OPTIONAL: \"raw\" or \"log\": \"raw\" is the default and should be used, unless metadata was provided to the mmpdb loadprops command during database initialization. In the latter case, this parameter enables customization of what data statistics are performed upon. Example: a property is stored in the DB as \"log\" units (as defined in the metadata), but we wish to perform statistics on the non-log, \"raw\" units, then specify \"raw\". If no metadata was provided, \"raw\" will use the raw data that was loaded with mmpdb loadprops.\n    - **units**: OPTIONAL: omit this field to use data as-is. Other options are \"M\" or \"uM\". Similar to **base** above, if metadata was provided, this parameter can be used to transform values e.g. from molar values stored in the DB, to micromolar values that is more digestible by certain users.\n- **range_filters**: OPTIONAL list of range_filter objects containing the below items, used to filter MMPs prior to statistical aggregation, based on the below criteria, e.g. every 'A' (i.e. left-hand-side) compound in an MMP must have a property_value <= x\n    - **compound**: either 'A' or 'B', referring to LHS or RHS of the MMP\n    - **property_name**: same description as property_name above\n    - **operator**: '<', '>', '<=', '>=', '=', '!='\n    - **base**: OPTIONAL: same description as base above\n    - **units**: OPTIONAL: same description as units above\n    - **value**: value to filter by\n\nReturns JSON with following items:\n\n- **minmax**: minimum and maximum values for properties and their statistics.\n- **column_headers**: Array of strings (i.e., headers) matching elements in below **rows**. The specific headers depend on **aggregation_type**. For example, when **aggregation_type** = \"individual_transforms\", below are the **column_headers** (details about what these headers refer to is provided):\n    - **\"rule_id\"**: id for the transform that defines the difference between the two compounds in MMPs\n    - **\"from_smiles\"**: SMILES for the left-hand-side fragment in the transform\n    - **\"to_smiles\"**: SMILES for the right-hand-side fragment in the transform\n    - **\"pair_count\"**: number of MMPs belonging to this transform\n    - **label of the form statistic + property_name + change_type**\n- **rows**: array of arrays (i.e., rows), with elements matching column_headers, where each row correspond to either a transform (when **aggregation_type** = \"individual_transforms\"), or a fragment (when **aggregation_type** = \"group_by_fragment\") \n- **grouped_by_environment**: false or true: whether or not the transforms are grouped by environment. Use this value as input to /get_plot_data endpoint. Only relevant for some queries with multiple points of attachment between variable and environment atoms, depending on symmetry","operationId":"aggregate_transforms_aggregate_transforms_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AggregationParameters"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/get_plot_data":{"post":{"summary":"Get Plot Data","description":"Get data for all MMPs associated with specific transform(s) or variable fragment(s).\n\nBefore calling this endpoint, first obtain output from /aggregate_transforms.\n\nAs input for this endpoint, the necessary ids for the transforms are provided by /aggregate_transforms. The matcher frontend uses this data to generate a scatterplot, e.g. change in property A vs. change in property B, where each point is an MMP belonging to specified transform(s).\n\nBody Parameters:\n\n- **query_id**: Number returned by /start_query endpoint to run the query of interest\n- **aggregation_type**: \"individual_transforms\" or \"group_by_fragment\": use the same value that was input to the /aggregate_transforms endpoint. see the description provided with /aggregate_transforms endpoint. This parameter affects the ID paradigm used for organizing groups of MMPs (\"ids\" parameter below)\n- **grouped_by_environment**: false or true: use the value returned by the /aggregate_transforms endpoint.\n- **ids**: list of ids for transforms or fragments: the format of the id depends on **aggregation_type** and **grouped_by_environment**:\n    - if **aggregation_type** = \"individual_transforms\" and **grouped_by_environment** = false, then each id is an integer rule_id returned by /aggregate_transforms\n    - if **aggregation_type** = \"individual_transforms\" and **grouped_by_environment** = true, then each id is a string with the form: from_smiles_env + \"_\" + to_smiles_env, where from_smiles_env and to_smiles_env are values returned by /aggregate_transforms\n    - if **aggregation_type** = \"group_by_fragment\" and **grouped_by_environment** = false, then each id is an integer rule_id, from the rule_id_array (all rule_id associated with a fragment), returned by /aggregate_transforms\n    - if **aggregation_type** = \"group_by_fragment\" and **grouped_by_environment** = true, then each id is a string of a variable fragment plus its environment: to_smiles_env, returned by /aggregate_transforms\n- **range_filters**: OPTIONAL list of range_filter objects, please refer to the documentation for range_filters under /aggregate_transforms endpoint\n\n**x_data** and **y_data**: This is just plain data about the MMPs. The reason we are calling the data \"x_data\" and \"y_data\" is because this endpoint was originally designed to get data for 2d graphs. This just means that you can get two types of data for MMPs with each call to this endpoint. x_data and y_data arguments can be identical.\n\n**x_data** and **y_data** are JSON objects with the following parameters:\n\n- **property_name**: This property_name should match one of the property_names that was passed in the previous call to /aggregate_transforms.\n- **change_type**: \"fold_change\", \"delta\" are two of the options, which respectively are B / A and B - A, where B is the property value of the RHS compound of the MMP, and A is the property value of the LHS compound of the MMP. Additional options (which do not actually represent changes in properties from one MMP to another) are \"A\" and \"B\", for the LHS and RHS compound property values, respectively, and \"average\", the average of A and B.\n- **base**: OPTIONAL: see description for base in /aggregate_transforms\n- **units**: OPTIONAL: see description for units in /aggregate_transforms\n\nReturns JSON with items:\n\n- **column_headers**: Array of following strings (details about what these labels refer to is provided):\n    - **\"from_construct_id\"**: id for the left-hand-side compound in the MMP (more technically, id for the data structure that ties the compound to its variable/constant fragments)\n    - **\"to_construct_id\"**: id for the right-hand-side compound in the MMP\n    - **\"rule_id\"**: id for the transform that defines the difference between the two compounds in the MMP\n    - Depending on the above input parameters \"aggregation_type\" and \"grouped_by_environment\", additional ids associated with such descriptors could be included\n    - **name for x_axis generated based on choice of property_name and change_type**\n    - **name for y_axis generated based on choice of property_name and change_type**\n- **rows**: array of arrays (i.e., rows) with elements matching the above column headers, one row per MMP","operationId":"get_plot_data_get_plot_data_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PlotParameters"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/get_pair_data":{"post":{"summary":"Get Pair Data","description":"Get data for specific MMPs\n\nBody Parameters:\n\n- **prop_changes**: Defines what property data is retrieved for each MMP. List of JSON objects with below parameters:\n    - **property_name**: This property_name should match one of the property_names that was passed in the previous calls to /aggregate_transforms and /get_plot_data.\n    - **change_type**: Either \"fold_change\" or \"delta\", see description for change type under /get_plot_data\n    - **base**: OPTIONAL: see description for base in /aggregate_transforms\n    - **units**: OPTIONAL: see description for units in /aggregate_transforms\n- **construct_id_pairs**: Array of arrays that define the MMPs: [from_construct_id, to_construct_id], which were returned by a previous call to /get_plot_data.\n\nReturns JSON with items:\n\n- **column_headers**: Array of the following strings labels (details about what these labels refer to is provided):\n    - **\"a_id\"**: original identifier for compound \"A\" (left-hand-side compound of MMP), e.g. a ChEMBL number\n    - **\"a\"**: SMILES for compound \"A\"\n    - **\"b_id\"**: original identifier for compound \"B\" (right-hand-side compound of MMP), e.g. a ChEMBL number\n    - **\"b\"**: SMILES for compound \"B\"\n    - **\"constant\"**: SMILES for the unchanging common substructure of both compounds in the MMP, i.e. the portion of the MMP compounds' structures that is not affected by the transform\n    - **label with the form a_property_name, depending on property name**: property value for compound A\n    - **label with the form b_property_name, depending on property name**: property value for compound B\n    - **label with the form property_name + \"_\" + change_type**: either a fold-change, or delta, of B's property value relative to A's property value\n- **rows**: array of arrays (i.e., rows) with elements matching the above column headers, one row per MMP","operationId":"get_pair_data_get_pair_data_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PairsCondensed"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/enumerate":{"post":{"summary":"Enumerate Designs","description":"Apply specific transforms from query results to the query input structures, to enumerate new designs based on transforms of interest.\n\nCurrently depends on data passed from the table of transform results displayed in the frontend.\n\nIn brief, the necessary transform data for this endpoint can be obtained from the /aggregate_transforms endpoint.","operationId":"enumerate_designs_enumerate_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/EnumerationData"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/snap_read/{snapshot_id}":{"get":{"summary":"Snap Read","description":"Read snapshot from database. The snapshot refers to input state and output filter state for a query. With this data, we can recreate input + output for a query of interest.\n\nThis way, users can save and share results simply by passing around a unique link containing the {snapshot_id} (in combination with functionality provided by the frontend API)\n\nThe snapshot would have previously been written using the snap_write endpoint.","operationId":"snap_read_snap_read__snapshot_id__get","parameters":[{"required":true,"schema":{"title":"Snapshot Id","type":"string"},"name":"snapshot_id","in":"path"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/snap_write":{"post":{"summary":"Snap Write","description":"Write snapshot to database. The snapshot refers to input state and output filter state for a query. With this data, we can recreate input + output for a query of interest.\n\nThis way, users can save and share results simply by passing around a unique link containing the {snapshot_id} (in combination with functionality provided by the frontend API)","operationId":"snap_write_snap_write_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueryInput"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/bind_snapquery_to_results/{snapquery_id}":{"get":{"summary":"Bind Snapquery To Results","description":"When the same query is run multiple times, it is wasteful to repeat the actual query, both in terms of time and disk space.\n\nFor queries saved with the snapshot feature, this endpoint allows us to avoid rerunning the query.\n\nHere we are just associating the snapshot data with the query_id of results in the database. When the frontend next sees a snapshot with this snapquery_id, the frontend will skip the query and instead load cached results.","operationId":"bind_snapquery_to_results_bind_snapquery_to_results__snapquery_id__get","parameters":[{"required":true,"schema":{"title":"Snapquery Id","type":"integer"},"name":"snapquery_id","in":"path"},{"required":true,"schema":{"title":"Query Id","type":"integer"},"name":"query_id","in":"query"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/propertyNames/":{"get":{"summary":"Propertynames","description":"This endpoint is used to populate the properties menu in the frontend input form.\n\nReturns JSON with items:\n\n- **properties**: Array of objects with items:\n    - **property_name**: string, name of property provided in input file to mmpdb loadprops command\n    - **display_name**: string, name of property to be displayed to users in frontend (if different from property_name, as defined in property metadata)","operationId":"propertyNames_propertyNames__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}},"/propertyMetadata/":{"get":{"summary":"Propertymetadata","description":"This function is needed for obtaining property metadata that was written to the database using the mmpdb loadprops command.\n\nThis metadata is depended upon by some of this API's endpoints that handle compound property data.\n\nReturns JSON with the following (for each property saved in the property_name table in the database):\n\n- **property_name**: object with below items:\n    - **base**: see /aggregate_transforms documentation for more details\n    - **unit**: see /aggregate_transforms documentation for more details\n    - **display_name**: alternate name of the property to display to users in frontend\n    - **display_unit**: preferred unit to display to users in frontend\n    - **change_displayed**: preferred change type, for compound property values of compounds in an MMP, to display to users in frontend","operationId":"propertyMetadata_propertyMetadata__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}},"/":{"get":{"summary":"Root","operationId":"root__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}},"/smilesToImage":{"get":{"summary":"Smilestoimage","description":"Utility endpoint for generating images in the frontend.\n\nParameters:\n\n- **smiles**: SMILES string of structure from which to generate an image\n- **x**: integer width of image\n- **y**: integer height of image\n- **scaleImage**: boolean controlling whether we scale the size of the image based on how large the molecule is","operationId":"smilesToImage_smilesToImage_get","parameters":[{"required":true,"schema":{"title":"Smiles","type":"string"},"name":"smiles","in":"query"},{"required":true,"schema":{"title":"X","type":"integer"},"name":"x","in":"query"},{"required":true,"schema":{"title":"Y","type":"integer"},"name":"y","in":"query"},{"required":false,"schema":{"title":"Scaleimage","type":"boolean","default":false},"name":"scaleImage","in":"query"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/smilesToImage_aligned":{"get":{"summary":"Smilestoimage Aligned","description":"Utility endpoint for generating images in the frontend.\n\nParameters:\n\n- **smiles**: SMILES string of structure from which to generate an image\n- **pattern**: SMILES string of pattern to which we want to align the molecule image generated from **smiles** input\n- **x**: integer width of image\n- **y**: integer height of image","operationId":"smilesToImage_aligned_smilesToImage_aligned_get","parameters":[{"required":true,"schema":{"title":"Smiles","type":"string"},"name":"smiles","in":"query"},{"required":true,"schema":{"title":"Pattern"},"name":"pattern","in":"query"},{"required":true,"schema":{"title":"X","type":"integer"},"name":"x","in":"query"},{"required":true,"schema":{"title":"Y","type":"integer"},"name":"y","in":"query"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}}},"components":{"schemas":{"AdvancedOptions":{"title":"AdvancedOptions","type":"object","properties":{"variable_min_heavies":{"title":"Variable Min Heavies","type":"integer","default":0},"variable_max_heavies":{"title":"Variable Max Heavies","type":"integer","default":0},"compound_min_heavies":{"title":"Compound Min Heavies","type":"integer","default":0},"compound_max_heavies":{"title":"Compound Max Heavies","type":"integer","default":0},"aggregation_type":{"title":"Aggregation Type","enum":["individual_transforms","group_by_fragment"],"type":"string","default":"individual_transforms"}},"examples":{"variable_min_heavies":0,"variable_max_heavies":0,"compound_min_heavies":0,"compound_max_heavies":0,"aggregation_type":"individual_transforms"}},"AggregationParameters":{"title":"AggregationParameters","required":["query_id","statistics"],"type":"object","properties":{"query_id":{"title":"Query Id","type":"integer"},"aggregation_type":{"title":"Aggregation Type","enum":["individual_transforms","group_by_fragment"],"type":"string","default":"individual_transforms"},"range_filters":{"title":"Range Filters","type":"array","items":{"$ref":"#/components/schemas/RangeFilter"},"default":[]},"statistics":{"title":"Statistics","type":"array","items":{"$ref":"#/components/schemas/Statistic"}}},"example":{"query_id":1,"aggregation_type":"individual_transforms","statistics":[{"statistic":"median","property_name":"hERG_pIC50","change_type":"fold_change","base":"raw","units":"uM"}]}},"EnumerationData":{"title":"EnumerationData","required":["query","query_id","row_data"],"type":"object","properties":{"query":{"$ref":"#/components/schemas/QueryInput"},"query_id":{"title":"Query Id","type":"integer"},"row_data":{"title":"Row Data","type":"array","items":{"type":"object"}},"link_address":{"title":"Link Address","type":"string","default":""}}},"GetAllRawData":{"title":"GetAllRawData","required":["query_id","query"],"type":"object","properties":{"query_id":{"title":"Query Id","type":"integer"},"query":{"$ref":"#/components/schemas/QueryInput"}}},"HTTPValidationError":{"title":"HTTPValidationError","type":"object","properties":{"detail":{"title":"Detail","type":"array","items":{"$ref":"#/components/schemas/ValidationError"}}}},"PairPropChange":{"title":"PairPropChange","required":["property_name","change_type"],"type":"object","properties":{"property_name":{"title":"Property Name","minLength":1,"type":"string"},"change_type":{"title":"Change Type","enum":["fold_change","delta"],"type":"string"},"base":{"title":"Base","enum":["raw","log"],"type":"string","default":"raw"},"units":{"title":"Units","enum":["uM","M"],"type":"string"}}},"PairsCondensed":{"title":"PairsCondensed","required":["prop_changes","construct_id_pairs"],"type":"object","properties":{"prop_changes":{"title":"Prop Changes","type":"array","items":{"$ref":"#/components/schemas/PairPropChange"}},"construct_id_pairs":{"title":"Construct Id Pairs","type":"array","items":{"maxItems":2,"minItems":2,"type":"array","items":{"type":"integer"}}}}},"PlotDataDimension":{"title":"PlotDataDimension","required":["property_name","change_type"],"type":"object","properties":{"property_name":{"title":"Property Name","minLength":1,"type":"string"},"change_type":{"title":"Change Type","enum":["A","B","average","fold_change","delta"],"type":"string"},"base":{"title":"Base","enum":["raw","log"],"type":"string","default":"raw"},"units":{"title":"Units","enum":["uM","M"],"type":"string"}}},"PlotParameters":{"title":"PlotParameters","required":["query_id","ids","x_data","y_data"],"type":"object","properties":{"query_id":{"title":"Query Id","type":"integer"},"aggregation_type":{"title":"Aggregation Type","enum":["individual_transforms","group_by_fragment"],"type":"string","default":"individual_transforms"},"grouped_by_environment":{"title":"Grouped By Environment","type":"boolean","default":false},"ids":{"title":"Ids","anyOf":[{"type":"array","items":{"type":"integer"}},{"type":"array","items":{"type":"string"}}]},"range_filters":{"title":"Range Filters","type":"array","items":{"$ref":"#/components/schemas/RangeFilter"},"default":[]},"x_data":{"$ref":"#/components/schemas/PlotDataDimension"},"y_data":{"$ref":"#/components/schemas/PlotDataDimension"}}},"QueryInput":{"title":"QueryInput","required":["query_type","transform_order","sketched_content"],"type":"object","properties":{"snapquery_id":{"title":"Snapquery Id","type":"string","default":""},"query_id":{"title":"Query Id","type":"integer","default":-1},"query_type":{"title":"Query Type","enum":["exact","substructure"],"type":"string"},"transform_order":{"title":"Transform Order","enum":["first_order","second_order"],"type":"string"},"sketched_content":{"$ref":"#/components/schemas/SketchedContent"},"REQUIRED_properties":{"title":"Required Properties","type":"string","default":""},"OPTIONAL_properties":{"title":"Optional Properties","type":"string","default":""},"advanced_options":{"title":"Advanced Options","allOf":[{"$ref":"#/components/schemas/AdvancedOptions"}],"default":{"variable_min_heavies":0,"variable_max_heavies":0,"compound_min_heavies":0,"compound_max_heavies":0,"aggregation_type":"individual_transforms"}},"snapfilter_id":{"title":"Snapfilter Id","type":"string","default":""},"snapfilter_string":{"title":"Snapfilter String","type":"string","default":""}},"example":{"snapquery_id":"","query_id":-1,"query_type":"exact","transform_order":"first_order","sketched_content":{"mol1_molfile":"\n  Ketcher  8112214332D 1   1.00000     0.00000     0\n\n  7  7  0  0  0  0            999 V2000\n    6.1042   -4.2292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.9702   -4.7292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.9702   -5.7292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.1042   -6.2292    0.0000 N   0  0  0  0  0  0  0  0  0  0  0  0\n    5.2382   -5.7292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    5.2382   -4.7292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.1042   -3.2292    0.0000 H   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0     0  0\n  2  3  2  0     0  0\n  3  4  1  0     0  0\n  4  5  2  0     0  0\n  5  6  1  0     0  0\n  6  1  2  0     0  0\n  1  7  1  0     0  0\nM  END\n","mol1_variable_atoms":"6","mol1_variable_bonds":"","mol1_environment_atoms":"0","mol1_environment_bonds":"","mol2_molfile":"\n  Ketcher  8112214352D 1   1.00000     0.00000     0\n\n  7  7  0  0  0  0            999 V2000\n    6.4583   -4.4792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    7.3243   -4.9792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    7.3243   -5.9792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.4583   -6.4792    0.0000 N   0  0  0  0  0  0  0  0  0  0  0  0\n    5.5923   -5.9792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    5.5923   -4.9792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.4583   -3.4792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0     0  0\n  2  3  2  0     0  0\n  3  4  1  0     0  0\n  4  5  2  0     0  0\n  5  6  1  0     0  0\n  6  1  2  0     0  0\n  1  7  1  0     0  0\nM  END\n","mol2_variable_atoms":"6","mol2_variable_bonds":"","mol2_environment_atoms":"0","mol2_environment_bonds":""},"REQUIRED_properties":"","OPTIONAL_properties":"hERG_pIC50","snapfilter_id":"","snapfilter_string":""}},"RangeFilter":{"title":"RangeFilter","required":["compound","property_name","operator","value"],"type":"object","properties":{"compound":{"title":"Compound","enum":["A","B"],"type":"string"},"property_name":{"title":"Property Name","minLength":1,"type":"string"},"operator":{"title":"Operator","enum":["<",">","<=",">=","=","!="],"type":"string"},"base":{"title":"Base","enum":["raw","log","negative_log"],"type":"string","default":"raw"},"units":{"title":"Units","enum":["uM","M"],"type":"string","default":"uM"},"value":{"title":"Value","type":"number"}}},"SketchedContent":{"title":"SketchedContent","type":"object","properties":{"mol1_molfile":{"title":"Mol1 Molfile","type":"string","default":""},"mol1_variable_atoms":{"title":"Mol1 Variable Atoms","type":"string","default":""},"mol1_variable_bonds":{"title":"Mol1 Variable Bonds","type":"string","default":""},"mol1_environment_atoms":{"title":"Mol1 Environment Atoms","type":"string","default":""},"mol1_environment_bonds":{"title":"Mol1 Environment Bonds","type":"string","default":""},"mol2_molfile":{"title":"Mol2 Molfile","type":"string","default":""},"mol2_variable_atoms":{"title":"Mol2 Variable Atoms","type":"string","default":""},"mol2_variable_bonds":{"title":"Mol2 Variable Bonds","type":"string","default":""},"mol2_environment_atoms":{"title":"Mol2 Environment Atoms","type":"string","default":""},"mol2_environment_bonds":{"title":"Mol2 Environment Bonds","type":"string","default":""}}},"Statistic":{"title":"Statistic","required":["statistic","property_name","change_type"],"type":"object","properties":{"statistic":{"title":"Statistic","enum":["median"],"type":"string"},"property_name":{"title":"Property Name","minLength":1,"type":"string"},"change_type":{"title":"Change Type","enum":["delta","fold_change"],"type":"string"},"base":{"title":"Base","enum":["raw","log"],"type":"string","default":"raw"},"units":{"title":"Units","enum":["uM","M"],"type":"string"}}},"ValidateSelectionInput":{"title":"ValidateSelectionInput","required":["selection_type","sketched_content"],"type":"object","properties":{"selection_type":{"title":"Selection Type","enum":["variable","environment"],"type":"string"},"sketched_content":{"$ref":"#/components/schemas/SketchedContent"},"mol1_selected_atoms":{"title":"Mol1 Selected Atoms","type":"string","default":""},"mol1_selected_bonds":{"title":"Mol1 Selected Bonds","type":"string","default":""},"mol2_selected_atoms":{"title":"Mol2 Selected Atoms","type":"string","default":""},"mol2_selected_bonds":{"title":"Mol2 Selected Bonds","type":"string","default":""}},"example":{"selection_type":"variable","sketched_content":{"mol1_molfile":"\n  Ketcher  8112214332D 1   1.00000     0.00000     0\n\n  7  7  0  0  0  0            999 V2000\n    6.1042   -4.2292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.9702   -4.7292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.9702   -5.7292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.1042   -6.2292    0.0000 N   0  0  0  0  0  0  0  0  0  0  0  0\n    5.2382   -5.7292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    5.2382   -4.7292    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.1042   -3.2292    0.0000 H   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0     0  0\n  2  3  2  0     0  0\n  3  4  1  0     0  0\n  4  5  2  0     0  0\n  5  6  1  0     0  0\n  6  1  2  0     0  0\n  1  7  1  0     0  0\nM  END\n","mol1_variable_atoms":"","mol1_variable_bonds":"","mol1_environment_atoms":"","mol1_environment_bonds":"","mol2_molfile":"\n  Ketcher  8112214352D 1   1.00000     0.00000     0\n\n  7  7  0  0  0  0            999 V2000\n    6.4583   -4.4792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    7.3243   -4.9792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    7.3243   -5.9792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.4583   -6.4792    0.0000 N   0  0  0  0  0  0  0  0  0  0  0  0\n    5.5923   -5.9792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    5.5923   -4.9792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    6.4583   -3.4792    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0     0  0\n  2  3  2  0     0  0\n  3  4  1  0     0  0\n  4  5  2  0     0  0\n  5  6  1  0     0  0\n  6  1  2  0     0  0\n  1  7  1  0     0  0\nM  END\n","mol2_variable_atoms":"","mol2_variable_bonds":"","mol2_environment_atoms":"","mol2_environment_bonds":""},"mol1_selected_atoms":"6","mol1_selected_bonds":"","mol2_selected_atoms":"6","mol2_selected_bonds":""}},"ValidationError":{"title":"ValidationError","required":["loc","msg","type"],"type":"object","properties":{"loc":{"title":"Location","type":"array","items":{"type":"string"}},"msg":{"title":"Message","type":"string"},"type":{"title":"Error Type","type":"string"}}}}}}